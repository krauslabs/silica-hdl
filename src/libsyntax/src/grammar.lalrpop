use ast::*;
use super::Ast;

grammar;

pub SourceFile: Ast = {
    "top" <module:Mod> => Ast{ top: module, },
};

Mod: Mod = {
    "mod" <id:Ident> "(" <ports:Ports> ")" "{" <stmts:Stmt*> "}" => Mod(id, ports, stmts),
};

Ports: Vec<Port> = Comma<Port>;

Port: Port = {
    "in" <id:Ident> ":" <ty:Type> => Port(Dir::Input, id, ty),
    "out" <id:Ident> ":" <ty:Type> => Port(Dir::Output, id, ty),
};

Type: Type = {
    "bool" => Type::Bool,
};

Stmt: Stmt = {
    <id:Ident> "=" <ex:Expr> ";" => Stmt::Assign(id, ex),
};

Expr: Expr = {
    <l:Expr> "&" <r:Term> => Expr::Binary(Box::new(l), BinaryOp::BitAnd, Box::new(r)),
    <l:Expr> "|" <r:Term> => Expr::Binary(Box::new(l), BinaryOp::BitOr, Box::new(r)),
    Term,
};

Term: Expr = {
    "(" <ex:Expr> ")" => ex,
    <id:Ident> => Expr::Ident(id),
    <lit:Litrl> => Expr::Litrl(lit),
};

Ident: Ident = {
    r"[a-zA-Z][0-9A-Za-z_]*" => Ident(<>.to_string()),
};

Litrl: Litrl = {
    r"[0-9]+" => Litrl(<>.to_string()),
};

// generic helper macros

Comma<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};
