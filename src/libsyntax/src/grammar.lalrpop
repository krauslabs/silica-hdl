use Ast;
use ast::*;
use lexer::{LexerError, Token};

grammar;

pub SourceFile: Ast = {
    "top" <module:Mod> => Ast{ top: module, },
};

Mod: Mod = {
    "mod" <id:Ident> "(" <ports:Ports> ")" "{" <stmts:Stmt*> "}" => Mod(id, ports, stmts),
};

Ports: Vec<Port> = Comma<Port>;

Port: Port = {
    "in" <id:Ident> ":" <ty:Type> => Port(Dir::Input, id, ty),
    "out" <id:Ident> ":" <ty:Type> => Port(Dir::Output, id, ty),
};

Type: Type = {
    "bit" => Type::Bit,
};

// Statements

Stmt: Stmt = {
    <id:Ident> "=" <ex:Expr> ";" => Stmt::Assign(id, ex),
};

// Expressions

Expr: Expr = ExprBitOr;

ExprBitOr: Expr = {
    <l:ExprBitOr> "|" <r:ExprBitXor> => Expr::Binary(Box::new(l), BinaryOp::BitOr, Box::new(r)),
    ExprBitXor,
};

ExprBitXor: Expr = {
    <l:ExprBitXor> "^" <r:ExprBitAnd> => Expr::Binary(Box::new(l), BinaryOp::BitXor, Box::new(r)),
    ExprBitAnd,
};

ExprBitAnd: Expr = {
    <l:ExprBitAnd> "&" <r:ExprShift> => Expr::Binary(Box::new(l), BinaryOp::BitAnd, Box::new(r)),
    ExprShift,
};

ExprShift: Expr = {
    <l:ExprShift> "<<" <r:ExprUnary> => Expr::Binary(Box::new(l), BinaryOp::ShiftLeft, Box::new(r)),
    <l:ExprShift> ">>" <r:ExprUnary> => Expr::Binary(Box::new(l), BinaryOp::ShiftRight, Box::new(r)),
    ExprUnary,
};

ExprUnary: Expr = {
    "~" <ex:ExprUnary> => Expr::Unary(UnaryOp::Negate, Box::new(ex)),
    "&" <ex:ExprUnary> => Expr::Unary(UnaryOp::ReductAnd, Box::new(ex)),
    "^" <ex:ExprUnary> => Expr::Unary(UnaryOp::ReductXor, Box::new(ex)),
    "|" <ex:ExprUnary> => Expr::Unary(UnaryOp::ReductOr, Box::new(ex)),
    ExprTerm,
};

ExprTerm: Expr = {
    "(" <ex:Expr> ")" => Expr::Paren(Box::new(ex)),
    <id:Ident> => Expr::Ident(id),
    <lit:Litrl> => Expr::Litrl(lit),
};

// Other Terminals

Ident: String = {
    "ident" => <>.to_string(),
};

Litrl: String = {
    "litrl" => <>.to_string(),
};

// Helper Macros

Comma<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

// Custom Lexer

extern {
    type Location = usize;
    type Error = LexerError;

    enum Token {
        // Identifiers
        "ident" => Token::Ident(<String>),

        // Literals
        "litrl" => Token::Litrl(<String>),

        // Punctuation
        "," => Token::Comma,
        ";" => Token::Semicolon,
        ":" => Token::Colon,
        "(" => Token::LeftParen,
        ")" => Token::RightParen,
        "{" => Token::LeftCurlyBrace,
        "}" => Token::RightCurlyBrace,

        // Operators
        "=" => Token::Assign,
        "~" => Token::Negate,
        "&" => Token::BitAnd,
        "|" => Token::BitOr,
        "^" => Token::BitXor,
        "<<" => Token::ShiftLeft,
        ">>" => Token::ShiftRight,

        // Keywords
        "mod" => Token::Mod,
        "top" => Token::Top,
        "in" => Token::In,
        "out" => Token::Out,
        "bit" => Token::Bit,
    }
}